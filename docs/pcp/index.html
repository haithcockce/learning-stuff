<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

</head>
<body>
  <style>
    @import '../site/style/base.css';
    code,a {
        color: #e63564;
    }
  </style>

  <section class="hero is-medium is-danger is-bold">
  <div class="hero-body">
    <div class="container">
      <h1 class="title">Performance Co-Pilot</h1>
      <h1 class="subtitle">Nope, you're not tripping! Now for performance troubleshooting, K?</h1>
    </div>
  </div>
</section>

<section class="section">
  <div class="container">
    <div class="content">
      <h1 class="title"><a href='https://drive.google.com/open?id=1kMVAKPLJRmsYXSaGEkWU5Jipza0JDkJZbhdSceRCcHg'>Now with a presentation!</a></h1>
    </div>
  </div>
</section>

<section class="section">
  <div class="container">
    <div class="content">
	    <h1 class="title"><a href='https://github.com/haithcockce/learning-stuff/tree/master/docs/pcp/custom-pmrep-views/'>Custom PMREP views</a></h1>
    </div>
  </div>
</section>

<section class="section">
  <div class="container">
    <h1 class="title is-spaced">Terminology and Concepts</h1>
    <div class="content">
      <p>The metrics themselves are described below first. Many of the concepts
      and entities in PCP can be thought of as "internal" and "external"
      where "external" entities are ones where a user may interact with
      directly, while "internal" entities are ones a user does not typically
      interact with directly but are used by other PCP components. Below, the
      internal and external components are described after the performance
      metrics are described.</p>
    </div>

    <h2 class="subtitle">Metrics, Metric Naming, and Metric Organization</h2>
    <div class="content">
      <ul>
        <li><p><b>Domain</b> A logical grouping of metrics typically based on
           source such as NFS Client, Nginx, Windows, Linux (kernel), etc</p></li>
        <li><p><b>PMNS</b> Performance Metrics Namespace is the method
          by which metrics are organized hierarchically into tree-like
          structures. Levels in the trees define the relationships between
          metrics within those subtrees. For example, paging activity would
          be a child of memory in general while page scanning and major
          faults would be children of paging activity. Typically, a PMNS is
          a single tree of metrics wherein a system can (and often will) have
          more than one PMNS available to use.</p></li>
        <li><p>The name of a performance metric is the path down through the
          PMNS delineated by '.' where the left-most parts of the metric name
          are the top levels of the hierarchy and the right-most parts are
          the bottom levels of the hierarchy.
	      <li><p><b>Example</b> <code>network.interface.in.bytes</code></p>
	        <ul>
            <li>The metric is part of the <i>network</i> namespace.</li>
            <li>The metric is part of a group of metrics describing network
              interface metrics.</li>
            <li>The metric is part of a group of metrics describing ingress
              traffic over network interfaces.</li>
            <li>The metric describes network ingress traffic over interfaces
              in terms of bytes.</li>
          </ul></li>
        <li><p><b>Example</b> <code>mem.util.swapFree</code></p>
          <ul>
            <li>The metric is part of the <i>memory</i> namespace.</li>
            <li>The metric is part of a group of metrics describing memory
              utilization metrics.</li>
            <li>The metric describes the amount of free space in the system's swap
              spaces and swapfiles.</li>
          </ul></li>
        <li><b>Instances</b> are literal sources of a metric such as the
          cumulative amount of swap space on the system or the currently
          running kernel version.</li>
        <li><b>Instance Domains</b> are collections of literal sources of
          metrics such as NICs, CPUs, disks, all PIDs, etc</li>
        <li><b>Example</b>
<pre>
 r7 # pminfo -f network.interface.in.bytes

network.interface.in.bytes                   ← Metric
    inst [0 or "eth0"] value 15853434        ← Instance <----- Instance Domain
    inst [1 or "lo"] value 18080             ← Instance <-/
</pre>
        </li>
      </ul>
    </div>


    <h2 class="subtitle">Internal Architectural Components</h2>
    <div class="content">
      <ul><p>
        <li><b>PMID</b> Performance Metric IDentifier. A unique value
          mapped to a specific metric. Typically you don't interact with
          this.</li>
        <li><b>PMDA</b> Performance Metric Domain Agent. A PMDA sits between
          other PCP components and the system-specific sources of metrics to
          retrieve metrics and convert them in a way consumable for PCP and
          other PCP components. Thus, metrics could come from a Mac OSX
          kernel (darwin), Linux kernel, or Windows kernels, as well as from
          applications such as Nginx, Informatica, Apache, etc.</li>
        <li><b>PMCD</b> Performance Metric Collector Daemon. The PMCD is the
          core internal component responsible for collecting metrics from PMDAs
          when requested by other components. PMCD must be running in order to
          gather metrics on a live system or record them into logs.</li>
      </ul>
    </div>


    <h2 class="subtitle">External Architectural Components</h2>
    <div class="content">
      <ul>
        <li><code>pminfo</code> Displays metrics in use, metadata and
          information about metrics themselves, as well as where the metric
          values are being pulled from. Can also present values of
          metrics.</li>
        <li><code>pmval</code> Dumps arbitrary metric values for a metric.
          Useful when needing to inspect a specific metric quickly.</li>
        <li><code>pmlogger</code> Daemon responsible for collecting and
          logging metrics for asynchronous metric analysis into archive
          files.</li>
        <li><code>pmrep</code> Performance metrics reporter. A highly
          customizable tool to present metrics nearly however desired. Most
          analysis with PCP data is done with pmrep.</li>
      </ul></p>
    </div>
  </div>
</section>



<section class="section">
  <div class="container">
    <h1 class="title">Visual Representation</h1>
    <p>Below is a visual representation of how all the core components work
    together.</p>
    <figure class="image is-2by1">
      <img src="pcp-architecure.png" class="has-ratio" width="1872" height="868">
    </figure>
  </div>
</section>

<section class="section">
  <div class="container">
    <h1 class="title">Basic Example Commands</h1>
    <div class="content">
<pre>
pcp collectl -s c --verbose
</pre>
<p>PCP runs a script which uses the PCP API to produce collectl-like output</p>
<pre>
pmrep :sar-B-old-kernel
</pre>
<p>pmrep produces paging activity represented in a SAR-like fashion</p>
<pre>
pmrep :vmstat
</pre>
<p>pmrep produces output similar to the vmstat tool</p>
<pre>
pcp mpstat -P ALL
</pre>
<p>CPU usage is presented for all CPUs via a script using the PCP API</p>
<pre>
pmrep :sar-u-ALL-P-ALL
</pre>
<p>CPU usage is presented for all CPUs similar to SAR</p>
    </div>
  </div>
</section>



<section class="section">
  <div class="container">
    <h1 class="title is-spaced">Common Usage in Support</h1>
    <h2 class="subtitle">Archives</h2>
    <div class="content">
      <ul>
        <li>Metrics can be logged with pmlogger into archives, similar to SAR’s
          sa files and *.raw.gz collectl logs</li>
        <li>Archives are stored in <code>/var/log/pcp/pmlogger/&lt;HOSTNAME&gt;/</code>
          by default</li>
        <li>Archives are named by the date the capture started and split into
          three files</li>
        <ul>
          <li>Data files, ending in .# (.0, .1, etc), contain the raw metric
            data</li>
          <li>Index files, ending in <code>.index</code>, and is a temporal
            index for data files to allow rapid access of data points</li>
  	      <li>Metadata files, ending in <code>.meta</code>, describe instance
            domains, metrics, etc captured, the timezone the data comes from,
            and other information about the archives</li>
        </ul>
        <li><b>Example</b></li>
<pre>
  -rw-r--r--. 1 pcp pcp   1229456 Jun 22 04:41 20200622.00.10.0.xz
  -rw-r--r--. 1 pcp pcp   1205188 Jun 22 09:11 20200622.00.10.1.xz
  -rw-r--r--. 1 pcp pcp   1213824 Jun 22 13:42 20200622.00.10.2.xz
  -rw-r--r--. 1 pcp pcp 104873740 Jun 22 18:13 20200622.00.10.3
  -rw-r--r--. 1 pcp pcp   1645140 Jun 22 18:17 20200622.00.10.4
  -rw-r--r--. 1 pcp pcp     71652 Jun 22 18:17 20200622.00.10.index
  -rw-r--r--. 1 pcp pcp   3633933 Jun 22 18:16 20200622.00.10.meta
</pre>
        <ul>
          <li>Each of the above all belong to the same data set, because they
            all start with the same prefix <code>20200622.00.10</code></li>
          <li>The prefix indicates the data starts at June 22 2020 at 12:10AM</li>
          <li>The files ending in <code>.0.xz</code>, <code>.1.xz</code>,
            <code>.2.xz</code>, <code>.3</code>, and <code>.4</code> are all raw
            binary data files</li>
          <li>The files ending in <code>.index</code> and <code>.meta</code> are
            the temporal index file and the meta data file for the data set
            respectively</ul>
      </ul>
    </div>


    <h2 class="subtitle">Common Options</h2>
    <h2 class="subtitle">Common Workflow</h2>
    <div class="content">
      <ol>
        <li><code>pcp-zeroconf</code> is a one-shot package to install and start
          necessary components for general support</li>
      </ol>
    </div>
  </div>
</section>


</body>
</html>
